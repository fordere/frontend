/**
 * Fordere WebService Console
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { AddFinalDayCompetitionRequest } from '../model/addFinalDayCompetitionRequest';
import { AddFinalDayTableRequest } from '../model/addFinalDayTableRequest';
import { AddGroupRequest } from '../model/addGroupRequest';
import { CreateNewRoundRequest } from '../model/createNewRoundRequest';
import { FinalDayCompetitionDto } from '../model/finalDayCompetitionDto';
import { FinalDayCompetitionProgressDto } from '../model/finalDayCompetitionProgressDto';
import { FinalDayDto } from '../model/finalDayDto';
import { FinalDayPlayerInCompetitionDto } from '../model/finalDayPlayerInCompetitionDto';
import { FinalDayTableDto } from '../model/finalDayTableDto';
import { GroupDto } from '../model/groupDto';
import { MatchDto } from '../model/matchDto';
import { MatchesResponse } from '../model/matchesResponse';
import { MoveTeamInGroupRequest } from '../model/moveTeamInGroupRequest';
import { OvertakeForderePlayerRequest } from '../model/overtakeForderePlayerRequest';
import { PutTeamOverToFinalDayCompetitionRequest } from '../model/putTeamOverToFinalDayCompetitionRequest';
import { SaveFinalDayCompetitionRequest } from '../model/saveFinalDayCompetitionRequest';
import { SaveGroupRequest } from '../model/saveGroupRequest';
import { TeamInGroupViewDto } from '../model/teamInGroupViewDto';
import { TogglePlayerActiveFinalDayCompetition } from '../model/togglePlayerActiveFinalDayCompetition';
import { UpdateFinalDayCompetitionNameRequest } from '../model/updateFinalDayCompetitionNameRequest';
import { UpdateFinalDayCompetitionStateRequest } from '../model/updateFinalDayCompetitionStateRequest';
import { UpdateFinalDayTableDisabledRequest } from '../model/updateFinalDayTableDisabledRequest';
import { UpdateFinalDayTableNumberRequest } from '../model/updateFinalDayTableNumberRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class FinaldayService {

    protected basePath = 'https://localhost:5001';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    /**
     * Add a FinalDay Competition
     * Add a FinalDay Competition
     * @param accept Accept Header
     * @param finalDayId 
     * @param name 
     * @param tableType 
     * @param competitionMode 
     * @param priority 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addFinalDayCompetition(accept: 'application/json', finalDayId?: number, name?: string, tableType?: string, competitionMode?: string, priority?: number, body?: AddFinalDayCompetitionRequest, observe?: 'body', reportProgress?: boolean): Observable<FinalDayCompetitionDto>;
    public addFinalDayCompetition(accept: 'application/json', finalDayId?: number, name?: string, tableType?: string, competitionMode?: string, priority?: number, body?: AddFinalDayCompetitionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FinalDayCompetitionDto>>;
    public addFinalDayCompetition(accept: 'application/json', finalDayId?: number, name?: string, tableType?: string, competitionMode?: string, priority?: number, body?: AddFinalDayCompetitionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FinalDayCompetitionDto>>;
    public addFinalDayCompetition(accept: 'application/json', finalDayId?: number, name?: string, tableType?: string, competitionMode?: string, priority?: number, body?: AddFinalDayCompetitionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling addFinalDayCompetition.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (finalDayId !== undefined && finalDayId !== null) {
            queryParameters = queryParameters.set('FinalDayId', <any>finalDayId);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('Name', <any>name);
        }
        if (tableType !== undefined && tableType !== null) {
            queryParameters = queryParameters.set('TableType', <any>tableType);
        }
        if (competitionMode !== undefined && competitionMode !== null) {
            queryParameters = queryParameters.set('CompetitionMode', <any>competitionMode);
        }
        if (priority !== undefined && priority !== null) {
            queryParameters = queryParameters.set('Priority', <any>priority);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FinalDayCompetitionDto>(`${this.configuration.basePath}/finalday/competitions`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a FinalDay Table
     * Add a FinalDay Table
     * @param accept Accept Header
     * @param finalDayId 
     * @param number 
     * @param tableType 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addFinalDayTable(accept: 'application/json', finalDayId?: number, number?: number, tableType?: string, body?: AddFinalDayTableRequest, observe?: 'body', reportProgress?: boolean): Observable<FinalDayTableDto>;
    public addFinalDayTable(accept: 'application/json', finalDayId?: number, number?: number, tableType?: string, body?: AddFinalDayTableRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FinalDayTableDto>>;
    public addFinalDayTable(accept: 'application/json', finalDayId?: number, number?: number, tableType?: string, body?: AddFinalDayTableRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FinalDayTableDto>>;
    public addFinalDayTable(accept: 'application/json', finalDayId?: number, number?: number, tableType?: string, body?: AddFinalDayTableRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling addFinalDayTable.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (finalDayId !== undefined && finalDayId !== null) {
            queryParameters = queryParameters.set('FinalDayId', <any>finalDayId);
        }
        if (number !== undefined && number !== null) {
            queryParameters = queryParameters.set('Number', <any>number);
        }
        if (tableType !== undefined && tableType !== null) {
            queryParameters = queryParameters.set('TableType', <any>tableType);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FinalDayTableDto>(`${this.configuration.basePath}/finalday/tables`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a Group to the given FinalDay Competition
     * Add a Group to the given FinalDay Competition
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addGroup(accept: 'application/json', finalDayCompetitionId: number, body?: AddGroupRequest, observe?: 'body', reportProgress?: boolean): Observable<GroupDto>;
    public addGroup(accept: 'application/json', finalDayCompetitionId: number, body?: AddGroupRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GroupDto>>;
    public addGroup(accept: 'application/json', finalDayCompetitionId: number, body?: AddGroupRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GroupDto>>;
    public addGroup(accept: 'application/json', finalDayCompetitionId: number, body?: AddGroupRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling addGroup.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling addGroup.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GroupDto>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(finalDayCompetitionId))}/group`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createNewRound(accept: 'application/json', finalDayCompetitionId: number, body?: CreateNewRoundRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createNewRound(accept: 'application/json', finalDayCompetitionId: number, body?: CreateNewRoundRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createNewRound(accept: 'application/json', finalDayCompetitionId: number, body?: CreateNewRoundRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createNewRound(accept: 'application/json', finalDayCompetitionId: number, body?: CreateNewRoundRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling createNewRound.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling createNewRound.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/finalday/competitions/${encodeURIComponent(String(finalDayCompetitionId))}/newround`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get\&#39;s all finished FinalDayCompetitions of a season
     * Get\&#39;s all finished FinalDayCompetitions of a season
     * @param accept Accept Header
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFinalDayCompetition(accept: 'application/json', id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteFinalDayCompetition(accept: 'application/json', id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteFinalDayCompetition(accept: 'application/json', id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteFinalDayCompetition(accept: 'application/json', id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling deleteFinalDayCompetition.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteFinalDayCompetition.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/finalday/competitions/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single finalday table
     * Delete a single finalday table
     * @param accept Accept Header
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFinalDayTable(accept: 'application/json', id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteFinalDayTable(accept: 'application/json', id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteFinalDayTable(accept: 'application/json', id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteFinalDayTable(accept: 'application/json', id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling deleteFinalDayTable.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteFinalDayTable.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/finalday/tables/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a single Group
     * Delete a single Group
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param groupId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteGroup(accept: 'application/json', finalDayCompetitionId: number, groupId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteGroup(accept: 'application/json', finalDayCompetitionId: number, groupId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteGroup(accept: 'application/json', finalDayCompetitionId: number, groupId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteGroup(accept: 'application/json', finalDayCompetitionId: number, groupId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling deleteGroup.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling deleteGroup.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling deleteGroup.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(finalDayCompetitionId))}/group/${encodeURIComponent(String(groupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param playerInFinalDayCompetitionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletePlayerInFinalDayCompetition(accept: 'application/json', playerInFinalDayCompetitionId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deletePlayerInFinalDayCompetition(accept: 'application/json', playerInFinalDayCompetitionId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deletePlayerInFinalDayCompetition(accept: 'application/json', playerInFinalDayCompetitionId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deletePlayerInFinalDayCompetition(accept: 'application/json', playerInFinalDayCompetitionId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling deletePlayerInFinalDayCompetition.');
        }
        if (playerInFinalDayCompetitionId === null || playerInFinalDayCompetitionId === undefined) {
            throw new Error('Required parameter playerInFinalDayCompetitionId was null or undefined when calling deletePlayerInFinalDayCompetition.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/finalday/players/${encodeURIComponent(String(playerInFinalDayCompetitionId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delets a team out of a group
     * Delets a team out of a group
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param teamInGroupId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTeamFromGroup(accept: 'application/json', finalDayCompetitionId: number, teamInGroupId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TeamInGroupViewDto>>;
    public deleteTeamFromGroup(accept: 'application/json', finalDayCompetitionId: number, teamInGroupId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TeamInGroupViewDto>>>;
    public deleteTeamFromGroup(accept: 'application/json', finalDayCompetitionId: number, teamInGroupId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TeamInGroupViewDto>>>;
    public deleteTeamFromGroup(accept: 'application/json', finalDayCompetitionId: number, teamInGroupId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling deleteTeamFromGroup.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling deleteTeamFromGroup.');
        }
        if (teamInGroupId === null || teamInGroupId === undefined) {
            throw new Error('Required parameter teamInGroupId was null or undefined when calling deleteTeamFromGroup.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<Array<TeamInGroupViewDto>>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(finalDayCompetitionId))}/group/deleteteam/${encodeURIComponent(String(teamInGroupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all finalday competitions
     * Gets all finalday competitions
     * @param accept Accept Header
     * @param finalDayId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllFinalDayCompetitions(accept: 'application/json', finalDayId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FinalDayCompetitionDto>>;
    public getAllFinalDayCompetitions(accept: 'application/json', finalDayId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FinalDayCompetitionDto>>>;
    public getAllFinalDayCompetitions(accept: 'application/json', finalDayId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FinalDayCompetitionDto>>>;
    public getAllFinalDayCompetitions(accept: 'application/json', finalDayId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getAllFinalDayCompetitions.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (finalDayId !== undefined && finalDayId !== null) {
            queryParameters = queryParameters.set('FinalDayId', <any>finalDayId);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<FinalDayCompetitionDto>>(`${this.configuration.basePath}/finalday/competitions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all finalday tables
     * Get all finalday tables
     * @param accept Accept Header
     * @param finalDayId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllFinalDayTables(accept: 'application/json', finalDayId?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FinalDayTableDto>>;
    public getAllFinalDayTables(accept: 'application/json', finalDayId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FinalDayTableDto>>>;
    public getAllFinalDayTables(accept: 'application/json', finalDayId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FinalDayTableDto>>>;
    public getAllFinalDayTables(accept: 'application/json', finalDayId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getAllFinalDayTables.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (finalDayId !== undefined && finalDayId !== null) {
            queryParameters = queryParameters.set('FinalDayId', <any>finalDayId);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<FinalDayTableDto>>(`${this.configuration.basePath}/finalday/tables`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single finalday
     * Get a single finalday
     * @param accept Accept Header
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinalDay(accept: 'application/json', id: number, observe?: 'body', reportProgress?: boolean): Observable<FinalDayDto>;
    public getFinalDay(accept: 'application/json', id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FinalDayDto>>;
    public getFinalDay(accept: 'application/json', id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FinalDayDto>>;
    public getFinalDay(accept: 'application/json', id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getFinalDay.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getFinalDay.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<FinalDayDto>(`${this.configuration.basePath}/finalday/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get\&#39;s a single finalday competition
     * Get\&#39;s a single finalday competition
     * @param accept Accept Header
     * @param id 
     * @param finalDayId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinalDayCompetition(accept: 'application/json', id: number, finalDayId?: number, observe?: 'body', reportProgress?: boolean): Observable<FinalDayCompetitionDto>;
    public getFinalDayCompetition(accept: 'application/json', id: number, finalDayId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FinalDayCompetitionDto>>;
    public getFinalDayCompetition(accept: 'application/json', id: number, finalDayId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FinalDayCompetitionDto>>;
    public getFinalDayCompetition(accept: 'application/json', id: number, finalDayId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getFinalDayCompetition.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getFinalDayCompetition.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (finalDayId !== undefined && finalDayId !== null) {
            queryParameters = queryParameters.set('FinalDayId', <any>finalDayId);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<FinalDayCompetitionDto>(`${this.configuration.basePath}/finalday/competitions/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param finalDayId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinalDayProgress(accept: 'application/json', finalDayId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FinalDayCompetitionProgressDto>>;
    public getFinalDayProgress(accept: 'application/json', finalDayId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FinalDayCompetitionProgressDto>>>;
    public getFinalDayProgress(accept: 'application/json', finalDayId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FinalDayCompetitionProgressDto>>>;
    public getFinalDayProgress(accept: 'application/json', finalDayId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getFinalDayProgress.');
        }
        if (finalDayId === null || finalDayId === undefined) {
            throw new Error('Required parameter finalDayId was null or undefined when calling getFinalDayProgress.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<FinalDayCompetitionProgressDto>>(`${this.configuration.basePath}/finalday/${encodeURIComponent(String(finalDayId))}/progress`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single finalday table
     * Get a single finalday table
     * @param accept Accept Header
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinalDayTable(accept: 'application/json', id: number, observe?: 'body', reportProgress?: boolean): Observable<FinalDayTableDto>;
    public getFinalDayTable(accept: 'application/json', id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FinalDayTableDto>>;
    public getFinalDayTable(accept: 'application/json', id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FinalDayTableDto>>;
    public getFinalDayTable(accept: 'application/json', id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getFinalDayTable.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getFinalDayTable.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<FinalDayTableDto>(`${this.configuration.basePath}/finalday/tables/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get\&#39;s all finished FinalDayCompetitions of a season
     * Get\&#39;s all finished FinalDayCompetitions of a season
     * @param accept Accept Header
     * @param finalDayId 
     * @param competitionMode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinishedFinalDayCompetitions(accept: 'application/json', finalDayId: number, competitionMode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FinalDayCompetitionDto>>;
    public getFinishedFinalDayCompetitions(accept: 'application/json', finalDayId: number, competitionMode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FinalDayCompetitionDto>>>;
    public getFinishedFinalDayCompetitions(accept: 'application/json', finalDayId: number, competitionMode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FinalDayCompetitionDto>>>;
    public getFinishedFinalDayCompetitions(accept: 'application/json', finalDayId: number, competitionMode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getFinishedFinalDayCompetitions.');
        }
        if (finalDayId === null || finalDayId === undefined) {
            throw new Error('Required parameter finalDayId was null or undefined when calling getFinishedFinalDayCompetitions.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (competitionMode !== undefined && competitionMode !== null) {
            queryParameters = queryParameters.set('CompetitionMode', <any>competitionMode);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<FinalDayCompetitionDto>>(`${this.configuration.basePath}/finalday/${encodeURIComponent(String(finalDayId))}/finished`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param finalDayId 
     * @param teamFilter 
     * @param page 
     * @param pageSize 
     * @param offset 
     * @param pagingRequested 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinishedFinalDayMatches(accept: 'application/json', finalDayId: number, teamFilter?: string, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'body', reportProgress?: boolean): Observable<MatchesResponse>;
    public getFinishedFinalDayMatches(accept: 'application/json', finalDayId: number, teamFilter?: string, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MatchesResponse>>;
    public getFinishedFinalDayMatches(accept: 'application/json', finalDayId: number, teamFilter?: string, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MatchesResponse>>;
    public getFinishedFinalDayMatches(accept: 'application/json', finalDayId: number, teamFilter?: string, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getFinishedFinalDayMatches.');
        }
        if (finalDayId === null || finalDayId === undefined) {
            throw new Error('Required parameter finalDayId was null or undefined when calling getFinishedFinalDayMatches.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (teamFilter !== undefined && teamFilter !== null) {
            queryParameters = queryParameters.set('TeamFilter', <any>teamFilter);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('Page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>offset);
        }
        if (pagingRequested !== undefined && pagingRequested !== null) {
            queryParameters = queryParameters.set('PagingRequested', <any>pagingRequested);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<MatchesResponse>(`${this.configuration.basePath}/finalday/${encodeURIComponent(String(finalDayId))}/matches/finished`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all groups in a FinalDayCompetition
     * Gets all groups in a FinalDayCompetition
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGroupsByCompetition(accept: 'application/json', finalDayCompetitionId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<GroupDto>>;
    public getGroupsByCompetition(accept: 'application/json', finalDayCompetitionId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<GroupDto>>>;
    public getGroupsByCompetition(accept: 'application/json', finalDayCompetitionId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<GroupDto>>>;
    public getGroupsByCompetition(accept: 'application/json', finalDayCompetitionId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getGroupsByCompetition.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling getGroupsByCompetition.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<GroupDto>>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(finalDayCompetitionId))}/group`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param finalDayId 
     * @param page 
     * @param pageSize 
     * @param offset 
     * @param pagingRequested 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRecentFinalDayMatches(accept: 'application/json', finalDayId: number, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'body', reportProgress?: boolean): Observable<MatchesResponse>;
    public getRecentFinalDayMatches(accept: 'application/json', finalDayId: number, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MatchesResponse>>;
    public getRecentFinalDayMatches(accept: 'application/json', finalDayId: number, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MatchesResponse>>;
    public getRecentFinalDayMatches(accept: 'application/json', finalDayId: number, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getRecentFinalDayMatches.');
        }
        if (finalDayId === null || finalDayId === undefined) {
            throw new Error('Required parameter finalDayId was null or undefined when calling getRecentFinalDayMatches.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('Page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>offset);
        }
        if (pagingRequested !== undefined && pagingRequested !== null) {
            queryParameters = queryParameters.set('PagingRequested', <any>pagingRequested);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<MatchesResponse>(`${this.configuration.basePath}/finalday/${encodeURIComponent(String(finalDayId))}/matches/recent`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param finalDayId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRunningFinalDayMatches(accept: 'application/json', finalDayId: number, observe?: 'body', reportProgress?: boolean): Observable<MatchDto>;
    public getRunningFinalDayMatches(accept: 'application/json', finalDayId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MatchDto>>;
    public getRunningFinalDayMatches(accept: 'application/json', finalDayId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MatchDto>>;
    public getRunningFinalDayMatches(accept: 'application/json', finalDayId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getRunningFinalDayMatches.');
        }
        if (finalDayId === null || finalDayId === undefined) {
            throw new Error('Required parameter finalDayId was null or undefined when calling getRunningFinalDayMatches.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<MatchDto>(`${this.configuration.basePath}/finalday/${encodeURIComponent(String(finalDayId))}/matches/running`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param finalDayId 
     * @param page 
     * @param pageSize 
     * @param offset 
     * @param pagingRequested 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUpcommingFinalDayMatches(accept: 'application/json', finalDayId: number, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'body', reportProgress?: boolean): Observable<MatchesResponse>;
    public getUpcommingFinalDayMatches(accept: 'application/json', finalDayId: number, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MatchesResponse>>;
    public getUpcommingFinalDayMatches(accept: 'application/json', finalDayId: number, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MatchesResponse>>;
    public getUpcommingFinalDayMatches(accept: 'application/json', finalDayId: number, page?: number, pageSize?: number, offset?: number, pagingRequested?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling getUpcommingFinalDayMatches.');
        }
        if (finalDayId === null || finalDayId === undefined) {
            throw new Error('Required parameter finalDayId was null or undefined when calling getUpcommingFinalDayMatches.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('Page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('Offset', <any>offset);
        }
        if (pagingRequested !== undefined && pagingRequested !== null) {
            queryParameters = queryParameters.set('PagingRequested', <any>pagingRequested);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<MatchesResponse>(`${this.configuration.basePath}/finalday/${encodeURIComponent(String(finalDayId))}/matches/upcomming`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Moves a TeamInGroup (Settlement)
     * Moves a TeamInGroup (Settlement)
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param teamInGroupId 
     * @param targetGroupId 
     * @param targetSettlement 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public moveTeamInGroup(accept: 'application/json', finalDayCompetitionId: number, teamInGroupId: number, targetGroupId?: number, targetSettlement?: number, body?: MoveTeamInGroupRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<TeamInGroupViewDto>>;
    public moveTeamInGroup(accept: 'application/json', finalDayCompetitionId: number, teamInGroupId: number, targetGroupId?: number, targetSettlement?: number, body?: MoveTeamInGroupRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TeamInGroupViewDto>>>;
    public moveTeamInGroup(accept: 'application/json', finalDayCompetitionId: number, teamInGroupId: number, targetGroupId?: number, targetSettlement?: number, body?: MoveTeamInGroupRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TeamInGroupViewDto>>>;
    public moveTeamInGroup(accept: 'application/json', finalDayCompetitionId: number, teamInGroupId: number, targetGroupId?: number, targetSettlement?: number, body?: MoveTeamInGroupRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling moveTeamInGroup.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling moveTeamInGroup.');
        }
        if (teamInGroupId === null || teamInGroupId === undefined) {
            throw new Error('Required parameter teamInGroupId was null or undefined when calling moveTeamInGroup.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (targetGroupId !== undefined && targetGroupId !== null) {
            queryParameters = queryParameters.set('TargetGroupId', <any>targetGroupId);
        }
        if (targetSettlement !== undefined && targetSettlement !== null) {
            queryParameters = queryParameters.set('TargetSettlement', <any>targetSettlement);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<TeamInGroupViewDto>>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(finalDayCompetitionId))}/group/moveteam/${encodeURIComponent(String(teamInGroupId))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds fordere player to Competition
     * Adds fordere player to Competition
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param playerId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public overtakeForderePlayer(accept: 'application/json', finalDayCompetitionId: number, playerId?: number, body?: OvertakeForderePlayerRequest, observe?: 'body', reportProgress?: boolean): Observable<FinalDayPlayerInCompetitionDto>;
    public overtakeForderePlayer(accept: 'application/json', finalDayCompetitionId: number, playerId?: number, body?: OvertakeForderePlayerRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FinalDayPlayerInCompetitionDto>>;
    public overtakeForderePlayer(accept: 'application/json', finalDayCompetitionId: number, playerId?: number, body?: OvertakeForderePlayerRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FinalDayPlayerInCompetitionDto>>;
    public overtakeForderePlayer(accept: 'application/json', finalDayCompetitionId: number, playerId?: number, body?: OvertakeForderePlayerRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling overtakeForderePlayer.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling overtakeForderePlayer.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (playerId !== undefined && playerId !== null) {
            queryParameters = queryParameters.set('PlayerId', <any>playerId);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FinalDayPlayerInCompetitionDto>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(finalDayCompetitionId))}/overtakeforderplayer`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public playersInFinalDayCompetition(accept: 'application/json', finalDayCompetitionId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FinalDayPlayerInCompetitionDto>>;
    public playersInFinalDayCompetition(accept: 'application/json', finalDayCompetitionId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FinalDayPlayerInCompetitionDto>>>;
    public playersInFinalDayCompetition(accept: 'application/json', finalDayCompetitionId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FinalDayPlayerInCompetitionDto>>>;
    public playersInFinalDayCompetition(accept: 'application/json', finalDayCompetitionId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling playersInFinalDayCompetition.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling playersInFinalDayCompetition.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<FinalDayPlayerInCompetitionDto>>(`${this.configuration.basePath}/finalday/competitions/${encodeURIComponent(String(finalDayCompetitionId))}/players`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Puts teams depending on given parameters into a group/finaldaycompetition
     * Puts teams depending on given parameters into a group/finaldaycompetition
     * @param accept Accept Header
     * @param id 
     * @param leagueId 
     * @param finalDayCompetitionId 
     * @param teamId 
     * @param groupId 
     * @param walkoverInGroupId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putTeamOverToFinalDayCompetition(accept: 'application/json', id: number, leagueId?: number, finalDayCompetitionId?: number, teamId?: number, groupId?: number, walkoverInGroupId?: number, body?: PutTeamOverToFinalDayCompetitionRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public putTeamOverToFinalDayCompetition(accept: 'application/json', id: number, leagueId?: number, finalDayCompetitionId?: number, teamId?: number, groupId?: number, walkoverInGroupId?: number, body?: PutTeamOverToFinalDayCompetitionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public putTeamOverToFinalDayCompetition(accept: 'application/json', id: number, leagueId?: number, finalDayCompetitionId?: number, teamId?: number, groupId?: number, walkoverInGroupId?: number, body?: PutTeamOverToFinalDayCompetitionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public putTeamOverToFinalDayCompetition(accept: 'application/json', id: number, leagueId?: number, finalDayCompetitionId?: number, teamId?: number, groupId?: number, walkoverInGroupId?: number, body?: PutTeamOverToFinalDayCompetitionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling putTeamOverToFinalDayCompetition.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling putTeamOverToFinalDayCompetition.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (leagueId !== undefined && leagueId !== null) {
            queryParameters = queryParameters.set('LeagueId', <any>leagueId);
        }
        if (finalDayCompetitionId !== undefined && finalDayCompetitionId !== null) {
            queryParameters = queryParameters.set('FinalDayCompetitionId', <any>finalDayCompetitionId);
        }
        if (teamId !== undefined && teamId !== null) {
            queryParameters = queryParameters.set('TeamId', <any>teamId);
        }
        if (groupId !== undefined && groupId !== null) {
            queryParameters = queryParameters.set('GroupId', <any>groupId);
        }
        if (walkoverInGroupId !== undefined && walkoverInGroupId !== null) {
            queryParameters = queryParameters.set('WalkoverInGroupId', <any>walkoverInGroupId);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(id))}/putteamover`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Saves a single finalday competition
     * Saves a single finalday competition
     * @param accept Accept Header
     * @param id 
     * @param name 
     * @param tableType 
     * @param competitionMode 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveFinalDayCompetition(accept: 'application/json', id: number, name?: string, tableType?: string, competitionMode?: string, body?: SaveFinalDayCompetitionRequest, observe?: 'body', reportProgress?: boolean): Observable<FinalDayCompetitionDto>;
    public saveFinalDayCompetition(accept: 'application/json', id: number, name?: string, tableType?: string, competitionMode?: string, body?: SaveFinalDayCompetitionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FinalDayCompetitionDto>>;
    public saveFinalDayCompetition(accept: 'application/json', id: number, name?: string, tableType?: string, competitionMode?: string, body?: SaveFinalDayCompetitionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FinalDayCompetitionDto>>;
    public saveFinalDayCompetition(accept: 'application/json', id: number, name?: string, tableType?: string, competitionMode?: string, body?: SaveFinalDayCompetitionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling saveFinalDayCompetition.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling saveFinalDayCompetition.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('Name', <any>name);
        }
        if (tableType !== undefined && tableType !== null) {
            queryParameters = queryParameters.set('TableType', <any>tableType);
        }
        if (competitionMode !== undefined && competitionMode !== null) {
            queryParameters = queryParameters.set('CompetitionMode', <any>competitionMode);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FinalDayCompetitionDto>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(id))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Save a single Group
     * Save a single Group
     * @param accept Accept Header
     * @param finalDayCompetitionId 
     * @param groupId 
     * @param numberOfSuccessor 
     * @param number 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveGroup(accept: 'application/json', finalDayCompetitionId: number, groupId: number, numberOfSuccessor?: number, number?: number, body?: SaveGroupRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public saveGroup(accept: 'application/json', finalDayCompetitionId: number, groupId: number, numberOfSuccessor?: number, number?: number, body?: SaveGroupRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public saveGroup(accept: 'application/json', finalDayCompetitionId: number, groupId: number, numberOfSuccessor?: number, number?: number, body?: SaveGroupRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public saveGroup(accept: 'application/json', finalDayCompetitionId: number, groupId: number, numberOfSuccessor?: number, number?: number, body?: SaveGroupRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling saveGroup.');
        }
        if (finalDayCompetitionId === null || finalDayCompetitionId === undefined) {
            throw new Error('Required parameter finalDayCompetitionId was null or undefined when calling saveGroup.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling saveGroup.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (numberOfSuccessor !== undefined && numberOfSuccessor !== null) {
            queryParameters = queryParameters.set('NumberOfSuccessor', <any>numberOfSuccessor);
        }
        if (number !== undefined && number !== null) {
            queryParameters = queryParameters.set('Number', <any>number);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/finalday/competition/${encodeURIComponent(String(finalDayCompetitionId))}/group/${encodeURIComponent(String(groupId))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param accept Accept Header
     * @param playerInFinalDayCompetitionId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public togglePlayerActiveFinalDayCompetition(accept: 'application/json', playerInFinalDayCompetitionId: number, body?: TogglePlayerActiveFinalDayCompetition, observe?: 'body', reportProgress?: boolean): Observable<object>;
    public togglePlayerActiveFinalDayCompetition(accept: 'application/json', playerInFinalDayCompetitionId: number, body?: TogglePlayerActiveFinalDayCompetition, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<object>>;
    public togglePlayerActiveFinalDayCompetition(accept: 'application/json', playerInFinalDayCompetitionId: number, body?: TogglePlayerActiveFinalDayCompetition, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<object>>;
    public togglePlayerActiveFinalDayCompetition(accept: 'application/json', playerInFinalDayCompetitionId: number, body?: TogglePlayerActiveFinalDayCompetition, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling togglePlayerActiveFinalDayCompetition.');
        }
        if (playerInFinalDayCompetitionId === null || playerInFinalDayCompetitionId === undefined) {
            throw new Error('Required parameter playerInFinalDayCompetitionId was null or undefined when calling togglePlayerActiveFinalDayCompetition.');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<object>(`${this.configuration.basePath}/finalday/players/${encodeURIComponent(String(playerInFinalDayCompetitionId))}/toggleactive`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the state of a FinalDay Competition
     * Update the state of a FinalDay Competition
     * @param accept Accept Header
     * @param id 
     * @param name 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFinalDayCompetitionName(accept: 'application/json', id: number, name?: string, body?: UpdateFinalDayCompetitionNameRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateFinalDayCompetitionName(accept: 'application/json', id: number, name?: string, body?: UpdateFinalDayCompetitionNameRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateFinalDayCompetitionName(accept: 'application/json', id: number, name?: string, body?: UpdateFinalDayCompetitionNameRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateFinalDayCompetitionName(accept: 'application/json', id: number, name?: string, body?: UpdateFinalDayCompetitionNameRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling updateFinalDayCompetitionName.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateFinalDayCompetitionName.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('Name', <any>name);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/finalday/competitions/${encodeURIComponent(String(id))}/name`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the state of a FinalDay Competition
     * Update the state of a FinalDay Competition
     * @param accept Accept Header
     * @param id 
     * @param competitionState 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFinalDayCompetitionState(accept: 'application/json', id: number, competitionState?: string, body?: UpdateFinalDayCompetitionStateRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateFinalDayCompetitionState(accept: 'application/json', id: number, competitionState?: string, body?: UpdateFinalDayCompetitionStateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateFinalDayCompetitionState(accept: 'application/json', id: number, competitionState?: string, body?: UpdateFinalDayCompetitionStateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateFinalDayCompetitionState(accept: 'application/json', id: number, competitionState?: string, body?: UpdateFinalDayCompetitionStateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling updateFinalDayCompetitionState.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateFinalDayCompetitionState.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (competitionState !== undefined && competitionState !== null) {
            queryParameters = queryParameters.set('CompetitionState', <any>competitionState);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/finalday/competitions/${encodeURIComponent(String(id))}/state`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the disabled state of a FinalDay table
     * Update the disabled state of a FinalDay table
     * @param accept Accept Header
     * @param id 
     * @param disabled 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFinalDayTableDisabled(accept: 'application/json', id: number, disabled?: boolean, body?: UpdateFinalDayTableDisabledRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateFinalDayTableDisabled(accept: 'application/json', id: number, disabled?: boolean, body?: UpdateFinalDayTableDisabledRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateFinalDayTableDisabled(accept: 'application/json', id: number, disabled?: boolean, body?: UpdateFinalDayTableDisabledRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateFinalDayTableDisabled(accept: 'application/json', id: number, disabled?: boolean, body?: UpdateFinalDayTableDisabledRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling updateFinalDayTableDisabled.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateFinalDayTableDisabled.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (disabled !== undefined && disabled !== null) {
            queryParameters = queryParameters.set('Disabled', <any>disabled);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/finalday/tables/${encodeURIComponent(String(id))}/disabled`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the number of a FinalDay table
     * Update the number of a FinalDay table
     * @param accept Accept Header
     * @param id 
     * @param number 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFinalDayTableNumber(accept: 'application/json', id: number, number?: number, body?: UpdateFinalDayTableNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateFinalDayTableNumber(accept: 'application/json', id: number, number?: number, body?: UpdateFinalDayTableNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateFinalDayTableNumber(accept: 'application/json', id: number, number?: number, body?: UpdateFinalDayTableNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateFinalDayTableNumber(accept: 'application/json', id: number, number?: number, body?: UpdateFinalDayTableNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling updateFinalDayTableNumber.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateFinalDayTableNumber.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (number !== undefined && number !== null) {
            queryParameters = queryParameters.set('Number', <any>number);
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/finalday/tables/${encodeURIComponent(String(id))}/number`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
